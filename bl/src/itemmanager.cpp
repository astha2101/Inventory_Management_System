#ifndef __ItemManager_cpp
#define __ItemManager_cpp 1
#include<bl\I_Item.h>
#include<bl\I_ItemManager.h>
#include<bl\ItemManager.h>
#include<bl\Item.h>
#include<bl\ItemCodeComparator.h>
#include<bl\ItemNameComparator.h>
#include<bl\ItemCategoryComparator.h>
#include<bl\ItemCategoryAndNameComparator.h>
#include<bl\ItemCategoryAndCodeComparator.h>
#include<bl\ItemNameAsKeyComparator.h>
#include<bl\bl.h>
#include<bl\CategoryWiseList>
#include<dl\Item.h>
#include<dl\I_Item.h>
#include<dl\ItemDL.h>
#include<dl\DLException.h>
#include<set>
#include<map>
#include<List>
#include<AbstractList>
#include<ListImplementation>
#include<forward_list>
#include<utility>
using namespace inventory_bl;
using namespace collections;




/*map<int,I_Item *> itemCodeMap;
map<const char *,I_Item *,ItemNameAsKeyComparator> itemNameMap;
set<I_Item *,ItemNameComparator> nameWiseSet;
set<I_Item *,ItemCodeComparator> codeWiseSet;
multiset<I_Item *,ItemCategoryAndCodeComparator> codeWiseMultiSet;
multiset<I_Item *,ItemCategoryAndNameComparator> nameWiseMultiSet;
*/
void ItemManager::populateDataStructures()
{
inventory_dl::ItemDL itemDataLayer;
forward_list<inventory_dl::I_Item *> *dlItems;
dlItems=itemDataLayer.getAll();
I_Item *item;
inventory_dl::I_Item *dlItem;
forward_list<inventory_dl::I_Item *>::iterator ii=dlItems->begin();
while(ii!=dlItems->end())
{
dlItem=*ii;
__$$__BL_ENUMERATION category;
if(dlItem->getCategory()=='r' || dlItem->getCategory()=='R')
{
category=RAW_MATERIAL;
this->numberOfRawMaterials++;
}else if(dlItem->getCategory()=='f' || dlItem->getCategory()=='F')
{
category=FINISHED_GOOD;
this->numberOfFinishedGoods++;
}else if(dlItem->getCategory()=='c' || dlItem->getCategory()=='C')
{
category=CONSUMABLE;
this->numberOfConsumables++;
}
item=new Item(dlItem->getCode(),dlItem->getName(),category);
this->itemCodeMap.insert(pair<int,I_Item *>(item->getCode(),item));
this->itemNameMap.insert(pair<const char *,I_Item *>(item->get_name(),item));
this->codeWiseSet.insert(item);
this->nameWiseSet.insert(item);
this->codeWiseMultiSet.insert(item);
this->nameWiseMultiSet.insert(item);
delete dlItem;
++ii;
}
delete dlItems;
}
ItemManager::ItemManager()
{
this->numberOfRawMaterials=0;
this->numberOfFinishedGoods=0;
this->numberOfConsumables=0;
populateDataStructures();
}
ItemManager::ItemManager(const ItemManager &other)
{
//do nothing
}
ItemManager & ItemManager::operator=(const ItemManager &other)
{
// do nothing
return *this;
}
void ItemManager::add(I_Item *item)
{
BLException blException;
if(item==NULL)
{
blException.setGenericException(string("Item required"));
throw blException;
}
int vCode=item->getCode();
string vName=item->getName();
string vCategory=item->getCategory();
if(vCode!=0) blException.addException(ITEM_CODE,string("Item code should be zero,it will be autogenerated"));
if(vName.length()==0) blException.addException(ITEM_NAME,string("Item name required"));
if(vName.length() > 75) blException.addException(ITEM_NAME,string("item name cannot exceed 75 characters"));
if(vCategory.length()==0) blException.addException(ITEM_CATEGORY,string("Item category required"));
if(blException.size()>0) throw blException;
if(this->itemNameMap.find(vName.c_str())!=this->itemNameMap.end())
{
char message[100];
sprintf(message,"Item : %s exists",vName.c_str());
blException.addException(ITEM_NAME,string(message));
throw blException;
}
inventory_dl::ItemDL itemDL;
inventory_dl::Item dlItem;
dlItem.setCode(0);
dlItem.setName(vName);
dlItem.setCategory(vCategory[0]);
try
{
itemDL.add(&dlItem);
vCode=dlItem.getCode();
item->setCode(vCode);
I_Item *blItem=new Item();
blItem->setCode(vCode);
blItem->setName(vName);
if(vCategory[0]=='F')
{
blItem->setCategory(FINISHED_GOOD);
this->numberOfFinishedGoods++;
}else if(vCategory[0]=='R')
{
blItem->setCategory(RAW_MATERIAL);
this->numberOfRawMaterials++;
}else if(vCategory[0]=='C')
{
blItem->setCategory(CONSUMABLE);
this->numberOfConsumables++;
}
itemCodeMap.insert(pair<int,I_Item *>(vCode,blItem));
itemNameMap.insert(pair<const char *,I_Item *>(blItem->get_name(),blItem));
codeWiseSet.insert(blItem);
nameWiseSet.insert(blItem);
codeWiseMultiSet.insert(blItem);
nameWiseMultiSet.insert(blItem);
}catch(inventory_dl::DLException dlException)
{
blException.setGenericException(dlException.getMessage());
throw blException;
}
}



void ItemManager::update(I_Item *item)
{
BLException blException;
if(item==NULL)
{
blException.setGenericException(string("Item required"));
throw blException;
}
int vCode=item->getCode();
string vName=item->getName();
string vCategory=item->getCategory();
if(vCode<=0)
{
char message[100];
sprintf(message,"Invalid item code : %d",vCode);
blException.addException(ITEM_CODE,string(message));
}
if(vName.length()==0) blException.addException(ITEM_NAME,string("Item name required"));
if(vName.length() > 75) blException.addException(ITEM_NAME,string("item name cannot exceed 75 characters"));
if(vCategory.length()==0) blException.addException(ITEM_CATEGORY,string("Item category required"));
map<int,I_Item *>::iterator iter=this->itemCodeMap.find(vCode);
if(iter==this->itemCodeMap.end())
{
char message[100];
sprintf(message,"Invalid item code : %d",vCode);
blException.addException(ITEM_CODE,string(message));
}
if(blException.size()>0) throw blException;
I_Item *dsItem=(*iter).second;
map<const char *,I_Item *,ItemNameAsKeyComparator>::iterator iter2=this->itemNameMap.find(vName.c_str());
if(iter2!=this->itemNameMap.end())
{
if(vCode!=(*iter2).second->getCode())
{
char message[100];
sprintf(message,"Item : %s exists",vName.c_str());
blException.addException(ITEM_NAME,string(message));
throw blException;
}
}
inventory_dl::ItemDL itemDL;
inventory_dl::Item dlItem;
dlItem.setCode(vCode);
dlItem.setName(vName);
dlItem.setCategory(vCategory[0]);
try
{
itemDL.update(&dlItem);
// remove from all the data structures other than those based on item code
itemNameMap.erase(dsItem->getName().c_str());
nameWiseSet.erase(dsItem);
nameWiseMultiSet.erase(dsItem);
codeWiseMultiSet.erase(dsItem);
string oldCategory=dsItem->getCategory();
if(oldCategory[0]=='F')
{
this->numberOfFinishedGoods--;
} 
else if(oldCategory[0]=='R')
{
this->numberOfRawMaterials--;
}
else if(oldCategory[0]=='C')
{
this->numberOfConsumables--;
}
dsItem->setName(vName);
if(vCategory[0]=='F')
{
dsItem->setCategory(FINISHED_GOOD);
this->numberOfFinishedGoods++;
}else if(vCategory[0]=='R')
{
dsItem->setCategory(RAW_MATERIAL);
this->numberOfRawMaterials++;
}else if(vCategory[0]=='C')
{
dsItem->setCategory(CONSUMABLE);
this->numberOfConsumables++;
}
itemNameMap.insert(pair<const char *,I_Item *>(dsItem->get_name(),dsItem));
nameWiseSet.insert(dsItem);
nameWiseMultiSet.insert(dsItem);
codeWiseMultiSet.insert(dsItem);
}catch(inventory_dl::DLException dlException)
{
blException.setGenericException(dlException.getMessage());
throw blException;
}
}




void ItemManager::remove(int code)
{
BLException blException;
if(code<=0)
{
char message[100];
sprintf(message,"Invalid item code : %d",code);
blException.addException(ITEM_CODE,string(message));
}
map<int,I_Item *>::iterator iter=this->itemCodeMap.find(code);
if(iter==this->itemCodeMap.end())
{
char message[100];
sprintf(message,"Invalid item code : %d",code);
blException.addException(ITEM_CODE,string(message));
}
if(blException.size()>0) throw blException;
I_Item *dsItem=(*iter).second;
inventory_dl::ItemDL itemDL;
try
{
itemDL.remove(code);
// remove from all the data structures other than those based on item code
itemNameMap.erase(dsItem->getName().c_str());
nameWiseSet.erase(dsItem);
nameWiseMultiSet.erase(dsItem);
codeWiseMultiSet.erase(dsItem);
itemCodeMap.erase(code);
codeWiseSet.erase(dsItem);
string oldCategory=dsItem->getCategory();
if(oldCategory[0]=='F')
{
this->numberOfFinishedGoods--;
} 
else if(oldCategory[0]=='R')
{
this->numberOfRawMaterials--;
}
else if(oldCategory[0]=='C')
{
this->numberOfConsumables--;
}
delete dsItem;
}catch(inventory_dl::DLException dlException)
{
blException.setGenericException(dlException.getMessage());
throw blException;
}
}
Item ItemManager::getByCode(int code)
{
map<int,I_Item *>::iterator iter=itemCodeMap.find(code);
if(iter==itemCodeMap.end())
{
char message[100];
sprintf(message,"Invalid item code : %d",code);
BLException blException;
blException.addException(ITEM_CODE,string(message));
throw blException;
}
Item *item=(Item *)(*iter).second;
return *item;
}


Item ItemManager::getByName(string name)
{
map<const char *,I_Item *,ItemNameAsKeyComparator>::iterator iter=this->itemNameMap.find(name.c_str());
if(iter==this->itemNameMap.end())
{
char message[100];
sprintf(message,"Invalid item : %s",name.c_str());
BLException blException;
blException.addException(ITEM_NAME,string(message));
throw blException;
}
Item *item=(Item *)(*iter).second;
return *item;
}


int ItemManager::getCount()
{
return this->itemCodeMap.size();
}

int ItemManager::getCountByCategory(__$$__BL_ENUMERATION category)
{
if(category==FINISHED_GOOD) return this->numberOfFinishedGoods;
else if(category==RAW_MATERIAL) return this->numberOfRawMaterials;
else if(category==CONSUMABLE) return this->numberOfConsumables;
return 0;
}

List<Item> ItemManager::getAll(__$$__BL_ENUMERATION orderBy)
{
if(orderBy==ITEM_CODE)
{
ListImplementation<I_Item *,Item,ItemCodeComparator> *itemsList;
itemsList=new ListImplementation<I_Item *,Item,ItemCodeComparator>(&codeWiseSet);
return List<Item>(itemsList);
}
else if(orderBy==CATEGORY_AND_NAME)
{
CategoryWiseList<ItemCategoryAndNameComparator> *itemsList;
itemsList=new CategoryWiseList<ItemCategoryAndNameComparator>(&nameWiseMultiSet,this->getCount());
return List<Item>(itemsList);
}
else if(orderBy==CATEGORY_AND_CODE)
{
CategoryWiseList<ItemCategoryAndCodeComparator> *itemsList;
itemsList=new CategoryWiseList<ItemCategoryAndCodeComparator>(&codeWiseMultiSet,this->getCount());
return List<Item>(itemsList);
}
ListImplementation<I_Item *,Item,ItemNameComparator> *itemsList;
itemsList=new ListImplementation<I_Item *,Item,ItemNameComparator>(&nameWiseSet);
return List<Item>(itemsList);
}



List<Item> ItemManager::getByCategory(__$$__BL_ENUMERATION category,__$$__BL_ENUMERATION orderBy)
{
if(category==CONSUMABLE)
{
if(orderBy==ITEM_CODE)
{
CategoryWiseList<ItemCategoryAndCodeComparator> *itemsList;
itemsList=new CategoryWiseList<ItemCategoryAndCodeComparator>(&codeWiseMultiSet,CONSUMABLE,this->numberOfConsumables);
return List<Item>(itemsList);
}
else
{
CategoryWiseList<ItemCategoryAndNameComparator> *itemsList;
itemsList=new CategoryWiseList<ItemCategoryAndNameComparator>(&nameWiseMultiSet,CONSUMABLE,this->numberOfConsumables);
return List<Item>(itemsList);
}
}
else if(category==FINISHED_GOOD)
{
if(orderBy==ITEM_CODE)
{
CategoryWiseList<ItemCategoryAndCodeComparator> *itemsList;
itemsList=new CategoryWiseList<ItemCategoryAndCodeComparator>(&codeWiseMultiSet,FINISHED_GOOD,this->numberOfFinishedGoods);
return List<Item>(itemsList);
}
else
{
CategoryWiseList<ItemCategoryAndNameComparator> *itemsList;
itemsList=new CategoryWiseList<ItemCategoryAndNameComparator>(&nameWiseMultiSet,FINISHED_GOOD,this->numberOfFinishedGoods);
return List<Item>(itemsList);
}
}
else if(category==RAW_MATERIAL)
{
if(orderBy==ITEM_CODE)
{
CategoryWiseList<ItemCategoryAndCodeComparator> *itemsList;
itemsList=new CategoryWiseList<ItemCategoryAndCodeComparator>(&codeWiseMultiSet,RAW_MATERIAL,this->numberOfRawMaterials);
return List<Item>(itemsList);
}
else
{
CategoryWiseList<ItemCategoryAndNameComparator> *itemsList;
itemsList=new CategoryWiseList<ItemCategoryAndNameComparator>(&nameWiseMultiSet,RAW_MATERIAL,this->numberOfRawMaterials);
return List<Item>(itemsList);
}
}
}



void ItemManager::removeAll()
{
try
{
inventory_dl::ItemDL itemDL;
itemDL.removeAll();
map<int,I_Item *>::iterator iter=this->itemCodeMap.begin();
I_Item *item;
while(iter!=this->itemCodeMap.end())
{
item=(*iter).second;
delete item;
++iter;
}
}catch(inventory_dl::DLException dlException)
{
BLException blException;
 blException.setGenericException(dlException.getMessage());
throw blException;
}
this->itemCodeMap.clear();
this->itemNameMap.clear();
this->codeWiseMultiSet.clear();
this->nameWiseMultiSet.clear();
this->nameWiseSet.clear();
this->codeWiseSet.clear();
}




/*void ItemManager::removeByCategory(__$$__BL_ENUMERATION category)
{
BLException blException;
if(category!=RAW_MATERIAL && category!=FINISHED_GOOD && category!=CONSUMABLE)
{
Item vItem;
vItem.setCategory(category);
char message[100];
sprintf(message,"Invalid item category : %s",vItem.getCategory());
BLException blException;
blException.addException(ITEM_CATEGORY,string(message));
throw blException;
}
Item item;
item.setCategory(category);
multiset<I_Item*,ItemCategoryAndCodeComparator>::iterator iter;
inventory_dl::ItemDL itemDL;
iter=this->codeWiseMultiSet.begin();
while(iter!=this->codeWiseMultiSet.end())
{
if((*iter)->getCategory()==item.getCategory())
{
I_Item* dsItem=(*iter);
int code=dsItem->getCode();
try
{
itemDL.remove(code);
itemNameMap.erase(dsItem->getName().c_str());
nameWiseSet.erase(dsItem);
nameWiseMultiSet.erase(dsItem);
itemCodeMap.erase(code);
codeWiseSet.erase(dsItem);
codeWiseMultiSet.erase(dsItem);
if(category==RAW_MATERIAL) this->numberOfRawMaterials--;
else if(category==FINISHED_GOOD) this->numberOfFinishedGoods--;
else if(category==CONSUMABLE) this->numberOfConsumables--;
}catch(inventory_dl::DLException dlException)
{
blException.setGenericException(dlException.getMessage());
throw blException;
}
}
iter++;
}
}
*/



void ItemManager::removeByCategory(__$$__BL_ENUMERATION category)
{
BLException blException;
if(category!=RAW_MATERIAL && category!=FINISHED_GOOD && category!=CONSUMABLE)
{
Item vItem;
vItem.setCategory(category);
char message[100];
sprintf(message,"Invalid item category : %s",vItem.getCategory());
BLException blException;
blException.addException(ITEM_CATEGORY,string(message));
throw blException;
}
List<Item> list=getByCategory(category,ITEM_CODE);
Item dsItem;
for(int i=0;i<list.getSize();i++)
{
dsItem=list.get(i);
int code=dsItem.getCode();
try
{
inventory_dl::ItemDL itemDL;
itemDL.remove(code);
this->itemNameMap.erase(dsItem.getName().c_str());
this->nameWiseSet.erase(&dsItem);
this->nameWiseMultiSet.erase(&dsItem);
this->itemCodeMap.erase(code);
this->codeWiseSet.erase(&dsItem);
if(category==RAW_MATERIAL) this->numberOfRawMaterials--;
else if(category==FINISHED_GOOD) this->numberOfFinishedGoods--;
else if(category==CONSUMABLE) this->numberOfConsumables--;
}catch(inventory_dl::DLException dlException)
{
blException.setGenericException(dlException.getMessage());
throw blException;
}
Item vItem;
vItem.setCode(0);
vItem.setCategory(category);
this->codeWiseMultiSet.erase(&vItem);
}
}




void ItemManager::removeByName(string name)
{
BLException blException;
if(name.length()==0)
{
char message[100];
sprintf(message,"Invalid item name : %s",name.c_str());
blException.addException(ITEM_NAME,string(message));
}
if(name.length()>75)
{
char message[100];
sprintf(message,"Invalid item name : %s",name.c_str());
blException.addException(ITEM_NAME,string(message));
}
map<const char *,I_Item *>::iterator iter=this->itemNameMap.find(name.c_str());
if(iter==this->itemNameMap.end())
{
char message[100];
sprintf(message,"Invalid item : %s",name.c_str());
BLException blException;
blException.addException(ITEM_NAME,string(message));
throw blException;
}
if(blException.size()>0) throw blException;
I_Item *dsItem=(*iter).second;
int code=dsItem->getCode();
inventory_dl::ItemDL itemDL;
try
{
itemDL.remove(code);
// remove from all the data structures other than those based on item code
itemNameMap.erase(dsItem->getName().c_str());
nameWiseSet.erase(dsItem);
nameWiseMultiSet.erase(dsItem);
codeWiseMultiSet.erase(dsItem);
itemCodeMap.erase(code);
codeWiseSet.erase(dsItem);
string oldCategory=dsItem->getCategory();
if(oldCategory[0]=='F')
{
this->numberOfFinishedGoods--;
} 
else if(oldCategory[0]=='R')
{
this->numberOfRawMaterials--;
}
else if(oldCategory[0]=='C')
{
this->numberOfConsumables--;
}
delete dsItem;
}catch(inventory_dl::DLException dlException)
{
blException.setGenericException(dlException.getMessage());
throw blException;
}
}
ItemManager::~ItemManager()
{
set<I_Item *,ItemCodeComparator>::iterator iter=this->codeWiseSet.begin();
I_Item *item;
while(iter!=this->codeWiseSet.end())
{
item=*iter;
delete item;
++iter;
}
} 
#endif